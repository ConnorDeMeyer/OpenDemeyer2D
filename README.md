# OpenDemeyer2D

OpenDemeyer2D is a 2D game engine and editor focused on Architecture over graphics. OpenDemeyer2D comes with an editor when run in Debug mode powered by ImGui allowing the user to change values and references at runtime without having the need to recompile the C++ code. It also comes with a serialization function that is able to output level files and complex GameObjects to files and vice-versa.

## GameObject

A `GameObject` or `GO` is a class that may contain `Components` to give functionality to the Objects. `Components` can be added or removed whenever the user wants.
It may also contain Children. Which are GameObject that will move/scale/rotate together with the GO whenever it also moves. Every `GameObject` automatically contains a `Transform Component`.
The `GO` has various useful methods:
 - `GetComponent<ComponentType>()` Gets the Typed Component that is owned by the GameObject.
 - `Update(float deltaTime)` is called once per frame for every GO and Component.
 - `LateUpdate()` is called after all the components and GO have been updated.
 - `Render()` is called at the end of the frame and will only do something if the GO contains a `Render Component`.
 - `InitializeComponents()` is called when the GO is initialized and will also call `Initialize()` on the Components.
 - `Destroy()` will flag the object to be destroyed at the end of the frame.
 - `GetWeakReference()` returns a `std::weak_reference` of the GO which allows the caller to have a reference to the GO which he can check if it is still valid.
 - `GetParent()` and `GetChildren` return the parent/Children.
It also has a Name that is displayed in the editor and a Tag that can be set by the user.

### Component

A `Component` is a class that inherits from `ComponentBase`. It also contains various virtual methods that can be overridden that give the class functionality during gameplay. these methods are: `Update(float)`, `LateUpdate()`, `Initialize()` and `BeginPlay()`. 
The Engine comes with some Components out of the box to define simple behaviors. Some of these are:
 - `Transform`: Component that defines the location is space and is automatically added to each `GameObject`.
 - `Render`: Is renders the bound texture after every Update loop.
 - `Physics Component`: Allows for setting up collision detection and responses.
 - `Sprite Component`: Allows the cycling of specific areas of a texture to create 2D animations.
 - etc...
 
When creating a component it should override from the ComponentBase class and should also have the Macro `COMPONENT_BODY(component_class)` inside of the class to give make it visible to the engine and give it some other functionality used in serialization and generating type information.
 
#### Game

A game is mainly compromised of Components that define the game logic. The Engine user just has to define the logic inside of functions and place them inside of the Editor.
A Component also has the `RenderImGui()` virtual method that can be used to change TypeInfo at runtime inside of the editor.

### Scene

A scene is a collection of `GameObjects` and is responsible for updating, rendering, creating and deleting them. Only one Scene may be active at the time. Scenes can also be loaded in from a file together with its containing `GameObjects` and `Components`.

### Prefabs

`Prefabs` are similar to scenes as they are a collection of `GameObjects` that are parented to each other each containing their own `Components`. These can then be `Instantiated` inside of the scene.

## Resources

`Resources` are data that is usually loaded from a file on the users system. These include things like `Sound Files`, `Textures`, `Fonts` or can be generated by the Engine like `RenderTargets`. Resources are managed by the `std::shared_ptr` class, meaning they will only go out of scope and release their resource when no one owns the resource anymore.
The `Resource Manager` is responsible for loading these Resources and is in some cases able to load them asynchronously so the player wont have to endure an fps drop.

## Delegates

`Delegates` are like events. It implements the Observer pattern. it can be a public or private member variable inside of a class that any subscribe to and can be invoked/broadcasted whenever the user wants. It is implemented with variadic templates meaning that any number of parameters can be passed in the event as long as the subscriber subscribes with a function that contains the same parameters Types.

## Memory Allocators

This engine includes various memory allocators that may be used to increase speed and avoid memory fragmentation:
 - `ObjectPoolAllocator`: Can be used to allocate classes of the same Type next to each other on the heap.
 - `SmallObjectAllocator`: Used to allocate objects of small size next to each other in a very efficient way avoiding the main cause of memory fragmentation.
 - `StackAllocator`: Used to quickly allocate memory that cannot be deallocated individually, only all at the same time.
 The Engine also overrides the `new` and `delete` operator to route through a `SmallObjectAllocator` automatically.

## Serialization

Every `Scene`, `GameObject`, `Component` and `Reference` can be serialized to a file. A `Scene` will output all its `GameObjects` who in turn will outputs its `Component` and children. If any Component has a std::weak_ptr to a `GameObject` or other `Component` it will also save it to a file and will be relinked when the file is loaded.

## Editor

The Editor is a big part of the Engine and allows the user to change the variables of the game and quickly replay through the levels without having to restart the program or recompile the C++ codebase.

![engineFull](https://user-images.githubusercontent.com/68373215/196522861-efc044dd-98b5-4c9b-b2ca-13b1ddb83e56.PNG)

### Scene Tree
![engineSceneGraph](https://user-images.githubusercontent.com/68373215/196523522-75e089a6-5aad-412e-9453-339aa4f7957a.PNG)

Every object can be selected, renamed, parented and deleted from the scene graph. You can also add more Game Objects from here.

#### Scene Object Selector

Inside of the scene you can also select any object with the mouse and it will become selected. Alternatively you can right click the Elements and it will show a list of all Objects underneath the cursor.

### Component Details
![engineComponents](https://user-images.githubusercontent.com/68373215/196523597-6b69ae17-17f5-40a0-8a14-75b470a8c9b7.png)

Here you can see, add, edit and remove Components from GameObjects.

### Play/Stop/Pause/Resume

You can Play the scene which will create a new scene that will start playing without changing the original. You may also pause gameplay and change variables when in game.

### File Viewer
![engineFiles](https://user-images.githubusercontent.com/68373215/196523581-f805c973-c594-44de-89b4-79abe866471a.PNG)

This area lets you inspect files and drag and drop them onto file fields inside of the Component Selector.

#### File Details

File details include file information and other functions like playing sound in case of Sound files.

### Render Information

Shows the Render Layers that are being rendered to. It also gives the option to render hitboxes of the Physics Components.

### Statistics
![engineStats](https://user-images.githubusercontent.com/68373215/196523560-2300783a-b543-48c6-afb6-2a0798b5605c.PNG)

Shows the Statistics of the Engine and Game. It also shows some infomration about the memory allocators used.

